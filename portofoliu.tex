% Created 2019-03-18 Mon 17:34
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{geometry}\geometry{a4paper,left=30mm,right=20mm,top=20mm,bottom=30mm}
\usepackage{titlesec}\titleformat*{\subsection}{}
\usepackage{etoolbox}\AtBeginEnvironment{minted}{\singlespacing\fontsize{12}{14}\selectfont}
\usepackage{mathtools}\usepackage{icomma}\usepackage{stackengine}\usepackage{amssymb}
\author{Pavel Andrei}
\date{}
\title{Portofoliu Algoritmi și complexitate}
\hypersetup{
 pdfauthor={Pavel Andrei},
 pdftitle={Portofoliu Algoritmi și complexitate},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.2)}, 
 pdflang={Romanian}}
\begin{document}

\maketitle

\section*{Laborator 1}
\label{sec:org6f7136e}
\subsection*{15. O colecție de \(n\) monede sunt identice, cu excepția uneia, falsă, care are greutatea mai mică decât a celorlalte. Propuneți o strategie pentru a identifica moneda falsă folosind o balanță simplă și cât mai puține cântăriri.}
\label{sec:orgfed1a71}

\begin{minted}[linenos,firstnumber=1,frame=single]{python}
import random, math
# The values aren't important, what matters is that fake < real
realWeight = 40
fakeWeight = 35

length = int(input("Please enter length: "))

coins = [realWeight] * length
coins[random.randrange(length)] = fakeWeight

bigPile = coins
steps = 0

while len(bigPile) > 1:
    steps += 1
    print("Step %d:" % steps)
    #we split the big pile in 3 piles with the same size ±1
    pileSize = len(bigPile) // 3 + (len(bigPile) % 3 == 2)
    leftPile = bigPile[0:pileSize]
    rightPile = bigPile[pileSize:pileSize*2]
    leftoverPile = bigPile[pileSize*2:]
    print("left", leftPile)
    print("right", rightPile)
    print("leftover", leftoverPile)
    difference = 0
    for i in range(pileSize):
        difference += rightPile[i] - leftPile[i]

    if difference > 0: bigPile = leftPile
    elif difference < 0: bigPile = rightPile
    else: bigPile = leftoverPile
    print()

print("Took", steps, "steps to find the fake coin, expected", 
      math.ceil(math.log(length, 3)))
\end{minted}

\begin{verbatim}
$ python3 src.py
Please enter length: 15
Step 1:
left [40, 40, 40, 40, 40]
right [40, 40, 40, 40, 40]
leftover [40, 40, 35, 40, 40]

Step 2:
left [40, 40]
right [35, 40]
leftover [40]

Step 3:
left [35]
right [40]
leftover []

Took 3 steps to find the fake coin, expected 3
\end{verbatim}

\subsection*{16. Bucătarul unui restaurant a pregătit clătite și le-a stivuit pe o farfurie. Fiind începător, clătitele nu au ieșit la fel, având diametre diferite, iar farfuria arată destul de rău. Bucătarul șef a vrut să-i dea o lecție și i-a dat sarcina de a rearanja (cea cu diametrul cel mai mare să fie prima pe farfurie, apoi cea cu diametrul imediat următor ca mărime ș.a.m.d.) folosind doar o spatulă. Ce strategie să adopte?}
\label{sec:org34c3d29}

\begin{minted}[linenos,firstnumber=1,frame=single]{python}
print("Please insert a space separated list of pancake diameters:\n(",
     end="")
strs = input().split(' ')
# index 0 represents the topmost pancake
pancakes = [int(num) for num in reversed(strs)]

def draw(msg, vec, spatulaIndex = -1):
    print(msg + "(", end="")
    i = len(vec)
    if spatulaIndex > 0: 
        for i in range(i-1, spatulaIndex-1, -1): print(vec[i], end=" ")
        print("|", end="")

    for i in range(i-1, -1, -1): print(vec[i], end=" ")
    print()

flips = 0
def flip(vec, index):
    global flips
    flips += 1
    draw("flip %2d: " % (flips), pancakes, index)
    for i in range(0, index//2):
        t = vec[i]
        vec[i] = vec[index-i-1]
        vec[index-i-1] = t

for bottom in range(len(pancakes), 0, -1):
    spatulaIndex = 0
    for i in range(0, bottom):
        if pancakes[i] >= pancakes[spatulaIndex]: spatulaIndex = i
    spatulaIndex += 1
    # if the biggest is at the bottom we do nothing
    if spatulaIndex == bottom: continue
    # if the biggest is already at the top we don't have to flip it
    if spatulaIndex != 1: flip(pancakes, spatulaIndex)

    flip(pancakes, bottom)

draw("", pancakes)
print("Done in %d flips" % flips)
\end{minted}

\begin{verbatim}
$ python3 src.py
Please insert a space separated list of pancake diameters:
(5 9 4 3 7 2 8 1
flip  1: (5 |9 4 3 7 2 8 1 
flip  2: (|5 1 8 2 7 3 4 9 
flip  3: (9 4 3 7 2 |8 1 5 
flip  4: (9 |4 3 7 2 5 1 8 
flip  5: (9 8 1 5 2 |7 3 4 
flip  6: (9 8 |1 5 2 4 3 7 
flip  7: (9 8 7 3 4 2 |5 1 
flip  8: (9 8 7 |3 4 2 1 5 
flip  9: (9 8 7 5 1 2 |4 3 
flip 10: (9 8 7 5 |1 2 3 4 
(9 8 7 5 4 3 2 1 
Done in 10 flips

$ python3 src.py
Please insert a space separated list of pancake diameters:
(4 3 2 1
(4 3 2 1 
Done in 0 flips

$ python3 src.py
Please insert a space separated list of pancake diameters:
(3 3 1 4 3
flip  1: (3 3 1 |4 3 
flip  2: (|3 3 1 3 4 
flip  3: (4 3 1 |3 3 
flip  4: (4 3 |1 3 3 
(4 3 3 3 1 
Done in 4 flips
\end{verbatim}

\pagebreak

\section*{Laborator 2}
\label{sec:orga452327}

\subsection*{10. Demonstrați corectitudinea algoritmului de determinare a valorii obținute prin inversarea ordinii cifrelor unui număr natural.}
\label{sec:org344c24e}

\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
#include <iostream>

int main() {
    unsigned n = 1234;
    //std::cin >> n;
    unsigned res = 0;
    int i = 0;
    while (n != 0) {
        res *= 10;
        res += n % 10;
        n /= 10;
        ++i;
    }
    std::cout << res << " I: " << i << "\n";
    return 0;
}
\end{minted}

\noindent
I. Parțial corectitudinea
\newline

Considerăm serțiunile de intrare și ieșire:

$P_{in} = \left\{ n = \sum\limits_{j=0}^{k} c_{j}10^{j};\ 
                c_{j} \in \overline{0,9} ,\ \forall j \in \overline{0,k};\ 
                c_{k} \neq 0 \right\}$,

$P_{out} = \left\{ \mathit{res} = \sum\limits_{j=0}^{k} c_{k-j}10^{j} \right\}$.

\vspace{14pt}
Alegem proprietatea:

$I = \left\{
              n = \sum\limits_{j=0}^{k-i}c_{i+j}10^{j};
              \mathit{res} = \sum\limits_{j=0}^{i-1}c_{i-1-j}10^{j}
 \right\}$.

\vspace{14pt}
La intrarea in buclă:

$i = 0$

$n = \sum\limits_{j=0}^{k}c_{j}10^{j}$

Deci propoziția
$I = \left\{
              n = \sum\limits_{j=0}^{k}c_{j}10^{j};
              \mathit{res} = \sum\limits_{j=0}^{-1}c_{-1-j}10^{j} = 0
      \right\}$ 
 este adevărată.

Arătăm că propoziția $I$ este invariantă.

Presupunem $I$ adevărata la începutul iterației și $n \ne 0$; demonstrăm $I$ adevărata la sfârșitul iterației.

$n = \sum\limits_{j=0}^{n-i}c_{i+j}10^{j};\ 
\mathit{res} = \sum\limits_{j=0}^{i-1}c_{i-1-j}10^{j}
$
\begin{minted}[linenos,firstnumber=9,frame=single]{cpp}
    res *= 10;
\end{minted}

$\mathit{res} = \left( \sum\limits_{j=0}^{i-1}c_{i-1-j}10^{j} \right) \cdot 10 
= \sum\limits_{j=0}^{i-1}c_{i-1-j}10^{j+1} 
= \sum\limits_{j=1}^{i}c_{i-j}10^{j}
$
\begin{minted}[linenos,firstnumber=10,frame=single]{cpp}
    res += n % 10;
\end{minted}

$\mathit{res} = \left( \sum\limits_{j=1}^{i}c_{i-j}10^{j} \right) + c_{i} 
= \left( \sum\limits_{j=1}^{i}c_{i-j}10^{j} \right) + c_{i-0}10^{0} 
= \sum\limits_{j=0}^{i}c_{i-j}10^{j}$

\begin{minted}[linenos,firstnumber=11,frame=single]{cpp}
    n /= 10;
\end{minted}

$n = \left[ \left( \sum\limits_{j=0}^{k-i}c_{i+j}10^{j} \right) / \ 10 \right]
= \left[ \sum\limits_{j=0}^{k-i}c_{i+j}10^{j-1} \right]
= \left[ \sum\limits_{j=1}^{k-i}c_{i+j}10^{j-1} \right] + \left[c_{i}10^{-1} \right]
$

Cum $0 \le c_{i} \le 9 \implies 0 \le c_{i}10^{-1} \le 0.9 \implies \left[c_{i}10^{-1} \right] = 0$.

Deci $n = \left[ \sum\limits_{j=1}^{k-i}c_{i+j}10^{j-1} \right] = \sum\limits_{j=1}^{k-i}c_{i+j}10^{j-1} = \sum\limits_{j=0}^{k-i-1}c_{i+j+1}10^{j}$. 

\begin{minted}[linenos,firstnumber=12,frame=single]{cpp}
    ++i;
\end{minted}

Scriem $\mathit{res}$ și $n$ în funcție de noul $i$. Deci $i$ devine $i-1$.


$\mathit{res} = \sum\limits_{j=0}^{i-1}c_{i-1-j}10^{j}$

$n = \sum\limits_{j=0}^{k-(i-1)-1}c_{i-1+j+1}10^{j} = \sum\limits_{j=0}^{k-i}c_{i+j}10^{j} $

Deci $I$ adevărata și la sfârșitul iterației.


\vspace{14pt}
La ieșirea din buclă:

$i = k + 1$

$n = \sum\limits_{j=0}^{k-(k+1)}c_{k+1+j}10^{j}
= \sum\limits_{j=0}^{-1}c_{k+1+j}10^{j} = 0$

$\mathit{res} = \sum\limits_{j=0}^{k+1-1}c_{k+1-1-j}10^{j}
= \sum\limits_{j=0}^{k}c_{k-j}10^{j}$

Deci $P_{out} = \left\{ res = \sum\limits_{j=0}^{k} c_{k-j}10^{j} \right\} $ adevărată.

În concluzie algoritmului este parțial corect.

\vspace{14pt}
\noindent
II. Total corectitudinea
\newline

Considerăm funcția $t: \mathbb{N} \to \mathbb{N}$, $t(i) = k + 1 - i$
$t(i + 1) - t(i) = k + 1 - (i + 1) - (k + 1 - i) = -1 < 0$, deci $t$ monoton strict descrescătoare.

$t(i) = 0 \iff i = k + 1 \iff n = \sum\limits_{j=0}^{-1}c_{k+1+j}10^{j} = 0\iff$ condiția de ieșire din buclă.

În concluzie algoritmului este total corect.

\pagebreak

\section*{Laborator 3}
\label{sec:org3e0c5af}

\subsection*{10. Considerăm o secvență \(x = (x_{0},..., x_{n-1})\) de \(n\) numere întregi, cu măcar un element pozitiv. O subsecvență a șirului este de forma \((x_{i}, x_{i+1},\ ...,\ x_{j})\), cu \(0 \le i \le j \le n - 1\), iar suma subsecvenței este suma elementelor componentelor sale. Descrieți un algoritm pentru a determina subsecvența de sumă maximă. Estimați timpul de execuție al algoritmului, precizând operația dominantă.}
\label{sec:orge429b99}

\begin{minted}[linenos,firstnumber=1,frame=single]{python}
print("Please insert the sequence: ", end="")
strs = input().split(' ')
v = [int(num) for num in strs]
n = len(v)
# python way of defining a n-dimensional list initialized to 0
sub_sums = [0 for i in range(0, n)]

best = (0, 0)
best_sum = 0
for i in range(0, n):
    sub_sums[i] = v[i]
    best_end_index = i
    # after this loop v[j] = (sum from k=i to j of v[k])
    for j in range(i+1, n):
        sub_sums[j] = sub_sums[j-1] + v[j]
        if sub_sums[j] > sub_sums[best_end_index]:
            best_end_index = j
    if sub_sums[best_end_index] > best_sum:
        best_sum = sub_sums[best_end_index]
        best = (i, best_end_index)

print("Best with a sum of", best_sum, "is: (x%d,...,x%d)" % best)
\end{minted}

\begin{verbatim}
$ python3 src.py
Please insert the sequence: 1 2 3 4
Best with a sum of 10 is: (x0,...,x3)

$ python3 src.py
Please insert the sequence: 1 -2 3 4
Best with a sum of 7 is: (x2,...,x3)

$ python3 src.py
Please insert the sequence: 1 2 -3 4
Best with a sum of 4 is: (x0,...,x3)
\end{verbatim}


\noindent

Considerăm operația de baza ca fiind compararea elementelor tabloului \texttt{v} (liniile 16 și 18).

Notăm $T_l(n) := $ timpul total de execuție al liniei $l$; T(n) := timpul de execuție total.

$T_{16}(n) = \sum\limits_{i=0}^{n-1} \sum\limits_{j=i+1}^{n-1}1 
= \sum\limits_{i=0}^{n-1}\left((n-1)-i\right)
= n(n-1) - \sum\limits_{i=0}^{n-1}i 
= n(n-1) - \frac{n(n-1)}{2}
= \frac{n(n-1)}{2}$


$T_{18}(n) = \sum\limits_{i=0}^{n-1}1 = n$

$T(n) = \frac{n(n-1)}{2} + n = \frac{n(n+1)}{2}$

\pagebreak



\section*{Laborator 4}
\label{sec:org81b30c0}

\subsection*{8. Considerăm o secvența  \(x = (x_0, ..., x_{n-1})\) de \(n\) numere întregi. Generați tabloul \(f = (f_0, ..., f_{n-1})\), cu \(f_i = \sum\limits_{j=0}^{i}x_j\), printr-un algoritm de complexitate liniară.}
\label{sec:orgf1f9b36}

\begin{minted}[linenos,firstnumber=1,frame=single]{python}
print("Please insert the sequence: ", end="")
strs = input().split(' ')
x = [int(num) for num in strs]
n = len(x)
f = [0 for i in range(n)]

f[0] = x[0]
for i in range(1, n):
    f[i] = f[i-1] + x[i]

print(f)

\end{minted}

\begin{verbatim}
$ python3 src.py
Please insert the sequence: 1 2 3 0 -1 5
[1, 3, 6, 6, 5, 10]
\end{verbatim}


\subsection*{9. Considerăm un tablou de valori întregi \(x = (x_0, ..., x_{n-1})\) și o valoare dată, s. Să se verifice daca există cel puțin doi indici \(i\) și \(j\) (nu neapărat distincți) cu proprietatea că \(x_i = x_j = s\). Analizați complexitatea algoritmului propus.}
\label{sec:org0228628}

\begin{minted}[linenos,firstnumber=1,frame=single]{python}
print("Please insert the sequence: ", end="")
strs = input().split(' ')
x = [int(num) for num in strs]
print("Please insert s: ", end="")
s = int(input())

def f(x):
    for i in range(0, len(x)):
        for j in range(i, len(x)):
            if x[i] + x[j] == s:
                print ("Found %d + %d = %d " % (x[i] , x[j], s))
                return True
    print("Not found")
    return False
f(x)
\end{minted}

\begin{verbatim}
$ python3 src.py
Please insert the sequence: 1 2 3 0 -1 5
Please insert s: 9
Not found

$ python3 src.py
Please insert the sequence: 1 2 3 0 5 -1
Please insert s: 7
Found 2 + 5 = 7 
\end{verbatim}


\pagebreak
\end{document}
