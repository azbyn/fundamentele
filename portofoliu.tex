% Created 2019-03-12 Tue 23:29
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{geometry}\geometry{a4paper,left=30mm,right=20mm,top=20mm,bottom=30mm}
\usepackage{titlesec}\titleformat*{\subsection}{}
\usepackage{etoolbox}\AtBeginEnvironment{minted}{\singlespacing\fontsize{12}{14}\selectfont}
\usepackage{mathtools}\usepackage{icomma}\usepackage{stackengine}\usepackage{amssymb}
\author{Pavel Andrei}
\date{}
\title{Portofoliu Algoritmi și complexitate}
\hypersetup{
 pdfauthor={Pavel Andrei},
 pdftitle={Portofoliu Algoritmi și complexitate},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.2)}, 
 pdflang={Romanian}}
\begin{document}

\maketitle

\section*{Laborator 3}
\label{sec:org4b9e96a}

\subsection*{{\bfseries\sffamily TODO} 10. Considerăm o secvență \(x = (x_{0},..., x_{n-1})\) de \(n\) numere întregi, cu măcar un element pozitiv. O subsecvență a șirului este de forma \((x_{i}, x_{i+1},...,x_{j})\), cu \(0 \le i \le j \le n - 1\), iar suma subsecvenței este suma elementelor componentelor sale. Descrieți un algoritm pentru a determina subsecvența de sumă maximă. Estimați timpul de execuție al algoritmului, precizând operația dominantă.}
\label{sec:org9301b56}

\begin{minted}[linenos,firstnumber=1,frame=single]{python}
print("Please insert the sequence: ", end="")
strs = input().split(' ')
v = [int(num) for num in strs]
n = len(v)
# python way of defining a n-dimensional list initialized to 0
sub_sums = [0 for i in range(0, n)]

best = (0, 0)
best_sum = 0
for i in range(0, n):
    sub_sums[i] = v[i]
    best_end_index = i
    # after this loop v[j] = (sum from k=i to j of v[k])
    for j in range(i+1, n):
        sub_sums[j] = sub_sums[j-1] + v[j]
        if sub_sums[j] > sub_sums[best_end_index]:
            best_end_index = j
    if sub_sums[best_end_index] > best_sum:
        best_sum = sub_sums[best_end_index]
        best = (i, best_end_index)

print("Best with a sum of", best_sum, "is: (x%d,...,x%d)" % best)
\end{minted}

\begin{verbatim}
$ python3 src.py
Please insert the sequence: 1 2 3 4
Best with a sum of 10 is: (x0,...,x3)
$ python3 src.py
Please insert the sequence: 1 -2 3 4
Best with a sum of 7 is: (x2,...,x3)
$ python3 src.py
Please insert the sequence: 1 2 -3 4
Best with a sum of 4 is: (x0,...,x3)
\end{verbatim}



\pagebreak
\noindent

Considerăm operația de baza ca fiind compararea elementelor tabloului \texttt{v} (liniile 16 și 18).

Notăm $T_l(n) := $ timpul total de execuție al liniei $l$; T(n) := timpul de execuție total.

$T_{16}(n) = \sum\limits_{i=0}^{n-1} \sum\limits_{j=i+1}^{n-1}1 
= \sum\limits_{i=0}^{n-1}\left((n-1)-i\right)
= n(n-1) - \sum\limits_{i=0}^{n-1}i 
= n(n-1) - \frac{n(n-1)}{2}
= \frac{n(n-1)}{2}$


$T_{18}(n) = \sum\limits_{i=0}^{n-1}1 = n$

$T(n) = \frac{n(n-1)}{2} + n = \frac{n(n+1)}{2}$
\end{document}
