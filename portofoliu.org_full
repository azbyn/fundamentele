#+TITLE: Portofoliu Algoritmi și complexitate
#+AUTHOR: Pavel Andrei
#+LANGUAGE: ro
#+LATEX_HEADER: \usepackage{geometry}\geometry{a4paper,left=30mm,right=20mm,top=20mm,bottom=30mm}
#+LATEX_HEADER: \usepackage{titlesec}\titleformat*{\subsection}{}
#+LATEX_HEADER: \usepackage{etoolbox}\AtBeginEnvironment{minted}{\singlespacing\fontsize{12}{14}\selectfont}
#+LATEX_HEADER: \usepackage{mathtools}\usepackage{icomma}\usepackage{stackengine}\usepackage{amssymb}
#+LATEX_HEADER: \usemintedstyle{vs}

# pastie vs xcode emacs borland

#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+OPTIONS: date:nil
#+ATTR_LATEX: :options frame=single

* Laborator 1
** 15. O colecție de $n$ monede sunt identice, cu excepția uneia, falsă, care are greutatea mai mică decât a celorlalte. Propuneți o strategie pentru a identifica moneda falsă folosind o balanță simplă și cât mai puține cântăriri.

# coins[12] = fakeWeight  :tangle moneda.py
#+BEGIN_SRC python -n :results output :exports code
import random, math
# The values aren't important, what matters is that fake < real
realWeight = 40
fakeWeight = 35

length = int(input("Please enter length: "))

coins = [realWeight] * length
coins[random.randrange(length)] = fakeWeight

bigPile = coins
steps = 0

while len(bigPile) > 1:
    steps += 1
    print("Step %d:" % steps)
    # we split the big pile in 3 piles with the same size ±1
    pileSize = len(bigPile) // 3 + (len(bigPile) % 3 == 2)
    leftPile = bigPile[0:pileSize]
    rightPile = bigPile[pileSize:pileSize*2]
    leftoverPile = bigPile[pileSize*2:]
    print("left", leftPile)
    print("right", rightPile)
    print("leftover", leftoverPile)
    difference = 0
    for i in range(pileSize):
        difference += rightPile[i] - leftPile[i]

    if difference > 0: bigPile = leftPile
    elif difference < 0: bigPile = rightPile
    else: bigPile = leftoverPile
    print()

print("Took", steps, "steps to find the fake coin, expected", 
      math.ceil(math.log(length, 3)))
#+END_SRC

#+BEGIN_SRC sh :results output :exports results
echo "$ python3 src.py"
echo "Please enter length: 15"
python3 src/moneda.py
#+END_SRC

** 16. Bucătarul unui restaurant a pregătit clătite și le-a stivuit pe o farfurie. Fiind începător, clătitele nu au ieșit la fel, având diametre diferite, iar farfuria arată destul de rău. Bucătarul șef a vrut să-i dea o lecție și i-a dat sarcina de a rearanja (cea cu diametrul cel mai mare să fie prima pe farfurie, apoi cea cu diametrul imediat următor ca mărime ș.a.m.d.) folosind doar o spatulă. Ce strategie să adopte?

# :tangle clatite.py
#+BEGIN_SRC python -n :results output :exports code 
print("Please insert a space separated list of pancake diameters:\n(",
     end="")
strs = input().split(' ')
# index 0 represents the topmost pancake
pancakes = [int(num) for num in reversed(strs) if num != ""]

def draw(msg, vec, spatulaIndex = -1):
    print(msg + "(", end="")
    i = len(vec)
    if spatulaIndex > 0: 
        for i in range(i-1, spatulaIndex-1, -1): print(vec[i], end=" ")
        print("|", end="")
        
    for i in range(i-1, -1, -1): print(vec[i], end=" ")
    print()

flips = 0
def flip(vec, index):
    global flips
    flips += 1
    draw("flip %2d: " % (flips), pancakes, index)
    for i in range(0, index//2):
        t = vec[i]
        vec[i] = vec[index-i-1]
        vec[index-i-1] = t

for bottom in range(len(pancakes), 0, -1):
    spatulaIndex = 0
    for i in range(0, bottom):
        if pancakes[i] >= pancakes[spatulaIndex]: spatulaIndex = i
    spatulaIndex += 1
    # if the biggest is at the bottom we do nothing
    if spatulaIndex == bottom: continue
    # if the biggest is already at the top we don't have to flip it
    if spatulaIndex != 1: flip(pancakes, spatulaIndex)
    
    flip(pancakes, bottom)

draw("", pancakes)
print("Done in %d flips" % flips)
#+END_SRC

#+BEGIN_SRC sh :results output :exports results
echo "$ python3 src.py"
python3 src/clatite.py "5 9 4 3 7 2 8 1"
echo -e "\n$ python3 src.py"
python3 src/clatite.py "4 3 2 1"
echo -e "\n$ python3 src.py"
python3 src/clatite.py "3 3 1 4 3"
#+END_SRC

\pagebreak

* Laborator 2

** 10. Demonstrați corectitudinea algoritmului de determinare a valorii obținute prin inversarea ordinii cifrelor unui număr natural.

#+BEGIN_SRC python -n :results output :exports code
n = int(input("Please insert n: "))

res = 0
i = 0

while n != 0:
    res *= 10
    res += n % 10
    n //= 10
    i += 1

print("Result:", res)
#+END_SRC

#+BEGIN_SRC sh :results output :exports results
python3 src/reversed.py "1234"
echo ""
python3 src/reversed.py "2400"
#python3 src/secventa.py "1 -2 3 4"
#+END_SRC

# doing it like this gives nicer syntax highlighting
#+begin_export latex
\noindent
I. Parțial corectitudinea
\newline

Considerăm serțiunile de intrare și ieșire:

$P_{in} = \left\{ n = \sum\limits_{j=0}^{k} c_{j}10^{j};\ 
                c_{j} \in \overline{0,9} ,\ \forall j \in \overline{0,k};\ 
                c_{k} \neq 0 \right\}$,

$P_{out} = \left\{ \mathit{res} = \sum\limits_{j=0}^{k} c_{k-j}10^{j} \right\}$.

\vspace{14pt}
Alegem proprietatea:

$I = \left\{
              n = \sum\limits_{j=0}^{k-i}c_{i+j}10^{j};
              \mathit{res} = \sum\limits_{j=0}^{i-1}c_{i-1-j}10^{j}
 \right\}$.

\vspace{14pt}
La intrarea in buclă:

$i = 0$

$n = \sum\limits_{j=0}^{k}c_{j}10^{j}$

Deci propoziția
$I = \left\{
              n = \sum\limits_{j=0}^{k}c_{j}10^{j};
              \mathit{res} = \sum\limits_{j=0}^{-1}c_{-1-j}10^{j} = 0
      \right\}$ 
 este adevărată.

Arătăm că propoziția $I$ este invariantă.

Presupunem $I$ adevărata la începutul iterației și $n \ne 0$; demonstrăm $I$ adevărata la sfârșitul iterației.

$n = \sum\limits_{j=0}^{n-i}c_{i+j}10^{j};\ 
\mathit{res} = \sum\limits_{j=0}^{i-1}c_{i-1-j}10^{j}
$
\begin{minted}[linenos,firstnumber=7,frame=single]{python}
    res *= 10
\end{minted}

$\mathit{res} = \left( \sum\limits_{j=0}^{i-1}c_{i-1-j}10^{j} \right) \cdot 10 
= \sum\limits_{j=0}^{i-1}c_{i-1-j}10^{j+1} 
= \sum\limits_{j=1}^{i}c_{i-j}10^{j}
$
\begin{minted}[linenos,firstnumber=8,frame=single]{python}
    res += n % 10
\end{minted}

$\mathit{res} = \left( \sum\limits_{j=1}^{i}c_{i-j}10^{j} \right) + c_{i} 
= \left( \sum\limits_{j=1}^{i}c_{i-j}10^{j} \right) + c_{i-0}10^{0} 
= \sum\limits_{j=0}^{i}c_{i-j}10^{j}$

\begin{minted}[linenos,firstnumber=9,frame=single]{python}
    n //= 10
\end{minted}

$n = \left[ \left( \sum\limits_{j=0}^{k-i}c_{i+j}10^{j} \right) / \ 10 \right]
= \left[ \sum\limits_{j=0}^{k-i}c_{i+j}10^{j-1} \right]
= \left[ \sum\limits_{j=1}^{k-i}c_{i+j}10^{j-1} \right] + \left[c_{i}10^{-1} \right]
$

Cum $0 \le c_{i} \le 9 \implies 0 \le c_{i}10^{-1} \le 0.9 \implies \left[c_{i}10^{-1} \right] = 0$.

Deci $n = \left[ \sum\limits_{j=1}^{k-i}c_{i+j}10^{j-1} \right] = \sum\limits_{j=1}^{k-i}c_{i+j}10^{j-1} = \sum\limits_{j=0}^{k-i-1}c_{i+j+1}10^{j}$. 

\begin{minted}[linenos,firstnumber=10,frame=single]{python}
    i += 1
\end{minted}

Scriem $\mathit{res}$ și $n$ în funcție de noul $i$. Deci $i$ devine $i-1$.


$\mathit{res} = \sum\limits_{j=0}^{i-1}c_{i-1-j}10^{j}$

$n = \sum\limits_{j=0}^{k-(i-1)-1}c_{i-1+j+1}10^{j} = \sum\limits_{j=0}^{k-i}c_{i+j}10^{j} $

Deci $I$ adevărata și la sfârșitul iterației.


\vspace{14pt}
La ieșirea din buclă:

$i = k + 1$

$n = \sum\limits_{j=0}^{k-(k+1)}c_{k+1+j}10^{j}
= \sum\limits_{j=0}^{-1}c_{k+1+j}10^{j} = 0$

$\mathit{res} = \sum\limits_{j=0}^{k+1-1}c_{k+1-1-j}10^{j}
= \sum\limits_{j=0}^{k}c_{k-j}10^{j}$

Deci $P_{out} = \left\{ res = \sum\limits_{j=0}^{k} c_{k-j}10^{j} \right\} $ adevărată.

În concluzie algoritmului este parțial corect.

\vspace{14pt}
\noindent
II. Total corectitudinea
\newline

Considerăm funcția $t: \mathbb{N} \to \mathbb{N}$, $t(i) = k + 1 - i$
$t(i + 1) - t(i) = k + 1 - (i + 1) - (k + 1 - i) = -1 < 0$, deci $t$ monoton strict descrescătoare.

$t(i) = 0 \iff i = k + 1 \iff n = \sum\limits_{j=0}^{-1}c_{k+1+j}10^{j} = 0\iff$ condiția de ieșire din buclă.

În concluzie algoritmului este total corect.

#+end_export

\pagebreak

* Laborator 3

** 10. Considerăm o secvență $x = (x_{0},..., x_{n-1})$ de $n$ numere întregi, cu măcar un element pozitiv. O subsecvență a șirului este de forma $(x_{i}, x_{i+1},\ ...,\ x_{j})$, cu $0 \le i \le j \le n - 1$, iar suma subsecvenței este suma elementelor componentelor sale. Descrieți un algoritm pentru a determina subsecvența de sumă maximă. Estimați timpul de execuție al algoritmului, precizând operația dominantă.

#+BEGIN_SRC python -n :results output :exports code
print("Please insert the sequence: ", end="")
strs = input().split(' ')
v = [int(num) for num in strs if num != ""]
n = len(v)
# python way of defining a n-dimensional list initialized to 0
sub_sums = [0 for i in range(0, n)]

best = (0, 0)
best_sum = 0
for i in range(0, n):
    sub_sums[i] = v[i]
    best_end_index = i
    # after this loop v[j] = (sum from k=i to j of v[k])
    for j in range(i+1, n):
        sub_sums[j] = sub_sums[j-1] + v[j]
        if sub_sums[j] > sub_sums[best_end_index]:
            best_end_index = j
    if sub_sums[best_end_index] > best_sum:
        best_sum = sub_sums[best_end_index]
        best = (i, best_end_index)

print("Best with a sum of", best_sum, "is: (x%d,...,x%d)" % best)
#+END_SRC

#+BEGIN_SRC sh :results output :exports results
echo "$ python3 src.py"
python3 src/secventa.py "1 2 3 4"
echo ""
echo "$ python3 src.py"
python3 src/secventa.py "1 -2 3 4"
echo ""
echo "$ python3 src.py"
python3 src/secventa.py "1 2 -3 4"
#echo "$ python3 src.py"
#python3 secventa.py "1 -2 3 4 -8 8 9 -2 12 9 1"

#+END_SRC


#+begin_export latex
\noindent

Considerăm operația de baza ca fiind compararea elementelor tabloului \texttt{v} (liniile 16 și 18).

Notăm $T_l(n) := $ timpul total de execuție al liniei $l$; $T(n) :=$ timpul de execuție total.

$T_{16}(n) = \sum\limits_{i=0}^{n-1} \sum\limits_{j=i+1}^{n-1}1 
= \sum\limits_{i=0}^{n-1}\left((n-1)-i\right)
= n(n-1) - \sum\limits_{i=0}^{n-1}i 
= n(n-1) - \frac{n(n-1)}{2}
= \frac{n(n-1)}{2}$


$T_{18}(n) = \sum\limits_{i=0}^{n-1}1 = n$

$T(n) = \frac{n(n-1)}{2} + n = \frac{n(n+1)}{2}$

#+end_export

\pagebreak

* Laborator 4

** 8. Considerăm o secvența  $x = (x_0, ..., x_{n-1})$ de $n$ numere întregi. Generați tabloul $f = (f_0, ..., f_{n-1})$, cu $f_i = \sum\limits_{j=0}^{i}x_j$, printr-un algoritm de complexitate liniară.

#+BEGIN_SRC python -n :results output :exports code
print("Please insert the sequence: ", end="")
strs = input().split(' ')
x = [int(num) for num in strs if num != ""]
n = len(x)
f = [0 for i in range(n)]

f[0] = x[0]
for i in range(1, n):
    f[i] = f[i-1] + x[i]

print(f)

#+END_SRC

#+BEGIN_SRC sh :results output :exports results
echo "$ python3 src.py"
python3 src/sum.py "1 2 3 0 -1 5"
#echo "$ python3 src.py"

#+END_SRC


** 9. Considerăm un tablou de valori întregi $x = (x_0, ..., x_{n-1})$ și o valoare dată, s. Să se verifice daca există cel puțin doi indici $i$ și $j$ (nu neapărat distincți) cu proprietatea că $x_i = x_j = s$. Analizați complexitatea algoritmului propus.

#+BEGIN_SRC python -n :results output :exports code
print("Please insert the sequence: ", end="")
strs = input().split(' ')
x = [int(num) for num in strs if str != ""]
print("Please insert s: ", end="")
s = int(input())

def f(x):
    for i in range(0, len(x)):
        for j in range(i, len(x)):
            if x[i] + x[j] == s:
                print ("Found %d + %d = %d " % (x[i] , x[j], s))
                return True
    print("Not found")
    return False
f(x)
#+END_SRC

#+BEGIN_SRC sh :results output :exports results
python3 src/l4_9.py "1 2 3 0 -1 5" "9"
echo ""

python3 src/l4_9.py "1 2 3 0 5 -1" "7"
#+END_SRC

\pagebreak

* Laborator 5

** 4. (\textit{Shaker sort}) modificând algoritmul de sortare prin interschimbarea elementelor vecine, sortați elementele unui tablou, astfel încât, la fiecare pas, să se plaseze pe pozițiile finale câte două elemente: minimul, respectiv maximul din subtabloul parcurs la pasul respectiv.

# :tangle shaker_sort.py
#+BEGIN_SRC python -n :results output :exports code
print("Please insert the array: ", end="")
strs = input().split(' ')
v = [int(num) for num in strs if num != ""]

def impl(start, end, step):
    sorted = True
    for i in range(start, end, step):
        if v[i] > v[i+1]:
            t = v[i]
            v[i] = v[i+1]
            v[i+1] = t
            sorted = False
    return sorted

begin = 0
end = len(v) - 1

while True:
    if impl(begin, end, 1): break
    if impl(end-1, begin-1, -1): break

    end -= 1
    begin += 1

print(v)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :results output :exports results
python3 src/shaker_sort.py "6 5 3 1 8 7 2 4 0 9"
echo ""
python3 src/shaker_sort.py "4 1 0 2 7 3 9 8 5 6"
echo ""
python3 src/shaker_sort.py "9 4 3 0 5 6 1 8 7 0"
echo ""
python3 src/shaker_sort.py "40 3 43 95 9 2 4 0"


#echo "$ python3 src.py"

#+END_SRC

** 5. (\textit{Counting sort} - sortare prin numărare) Considerăm un tablou $x$ de dimensiune $n$, cu elemente din mulțimea $\{0, 1, 2,...,m\}$. Pentru sortarea unui astfel de tablou poate fi descris un algoritm de sortare de complexitate liniară, dacă $m$ nu este semnificativ mai mare ca $n$. Pașii algoritmul sunt:
#+begin_export latex
\begin{enumerate}
\item [(a)] se construiește tabloul $f[0..m]$ al frecvențelor de apariție a elementelor tabloului $x$ ($f_i$ reprezintă de câte ori apare valoarea $i$ în tabloul $x$, $i = 0,...,m$);

\item [(b)] se calculează tabloul frecvențelor cumulate $\mathit{fc}[0..m]$, $\mathit{fc}_i = \sum\limits_{j=0}^{i}f_j$,\ $i = 0,...,m$;
\item [(c)] se folosește tabloul frecvențelor cumulate pentru a construi tabloul ordonat.
\end{enumerate}

Descrieți algoritmul de sortare prin numărare. Care este complexitatea acestuia?
#+end_export


#+BEGIN_SRC python -n :results output :exports code
print("Please insert the array: ", end="")
x = [int(num) for num in (input().split()) if num != ""]
n = len(x)
m = max(x) + 1

f = [0 for i in range(m)]
output = [0 for i in range(n)]

for i in x: f[i] += 1
print("f:", f)

for i in range(1, m): f[i] = f[i-1] + f[i]

print("fc:", f)
for i in range(n):
    val = x[i]
    f[val] -= 1
    output[f[val]] = val

print("output:", output)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :results output :exports results
python3 src/counting_sort.py "0 1 2 2 1 0 2 1 2 4"
echo ""
#python3 counting_sort.py "0 1 2 2 1 0 2 1 2"
#echo ""
python3 src/counting_sort.py "1 2 2 1 2 1 2 4"
#+END_SRC


#+begin_export latex
Considerăm atribuirile în vectori ca fiind operațiile de bază (ignorăm inițializările).

Notăm $T_l := $ timpul total de execuție al liniei $l$; $T(n, m) :=$ timpul de execuție total.

$T_{9} = n$;
$T_{12} = m - 1$;
$T_{17} = n$;
$T_{18} = n$;

$T(n, m) = 3n + m - 1$.

\vspace{7pt}
$T \in O(n+m)$.
#+end_export

** 6. (\textit{Radix sort} - sortare pe baza cifrelor) Considerăm un tablou $x$ de dimensiune $n$, cu elemente numere naturale de cel mult k cifre. Algoritmul de sortare este bazat pe următoarea idee: folosind counting sort, se ordonează tabloul în raport cu cifra cea mai puțin semnificativă a fiecărui număr, apoi se sortează în raport cu cifra de rang imediat superior ș.a.m.d., până de ajunge la cifra cea mai semnificativă. $\\$ Descrieți algoritmul radix sort. Care este complexitatea acestuia?

#+BEGIN_SRC python -n :results output :exports code
print("Please insert the array: ", end="")
x = [int(num) for num in (input().split()) if num != ""]
n = len(x)
max_x = max(x)

f = [0 for i in range(10)]
output = [0 for i in range(n)]

pow10 = 1
while max_x > 0:
    def getDigit(num): return (num // pow10) % 10

    for i in range(10): f[i] = 0
    for i in x: f[getDigit(i)] += 1

    for i in range(1, 10): f[i] += f[i-1]

    for i in range(n - 1, -1, -1):
        index = getDigit(x[i])
        f[index] -= 1
        output[f[index]] = x[i]

    #output becomes new input
    for i in range(n): x[i] = output[i]
    
    pow10 *= 10
    max_x //= 10

print("output:", output)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :results output :exports results
python3 src/radix_sort.py "3 2 4 23 427 459 56 90"
echo ""
python3 src/radix_sort.py "89568 23 123 2 1 4 45 499"
#+END_SRC

#+begin_export latex
Considerăm atribuirile în vectori ca fiind operațiile de bază (ignorăm inițializările).

Notăm $k = \mathit{log10}(\mathit{max}(x)) + 1$; $T_l := $ timpul total de execuție al liniei $l$; $T(n, k) :=$ timpul de execuție total.

$T_{13} = 10 k$;
$T_{14} = k n$;
$T_{16} = 9 k$;
$T_{20} = k n$;
$T_{21} = k n$;

$T(n, k) = 3kn + 19k$.

\vspace{7pt}
$T \in O(kn)$.

#+end_export




