% Created 2019-05-09 Thu 23:36
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{geometry}\geometry{a4paper,left=30mm,right=20mm,top=20mm,bottom=30mm}
\usepackage{titlesec}\titleformat*{\subsection}{}
\usepackage{etoolbox}\AtBeginEnvironment{minted}{\singlespacing\fontsize{12}{14}\selectfont}
\usepackage{mathtools}\usepackage{icomma}\usepackage{stackengine}\usepackage{amssymb}
\author{Pavel Andrei}
\date{}
\title{Portofoliu Algoritmi și complexitate}
\hypersetup{
 pdfauthor={Pavel Andrei},
 pdftitle={Portofoliu Algoritmi și complexitate},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.2 (Org mode 9.2)}, 
 pdflang={Romanian}}
\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{3cm}
 
 
        \Huge
        \textbf{Portofoliu Algoritmi și complexitate - Probleme rezonabile}

        \vspace{0.5cm}
        \LARGE
        Anul I, semestrul 2

        \vspace{3cm}
        \Large
        {Numele tău aici}\\
        \vspace{5cm}
 
        %\vfill
 
        \vspace{0.8cm}
 
 
    \end{center}
        \Large
        1. Dacă vreți probleme rezolvate mai grele intrati \href{https://github.com/azbyn/fundamentele/blob/master/portofoliu.pdf}{aici};\\
        2. Dacă nu înțelegeți ceva întrebați-mă;\\
        3. Vă invit sa mai adăugați și problemele voastre (da, știu);\\
        4. Dacă găsiți ceva greșit spuneți-mi;\\
        5. Nu scrieți comentariile, sunt mai mult pentru amuzamentul meu.
 
\end{titlepage}

\section*{Laborator 1}
\label{sec:org05748f3}
\subsection*{8. Aproximați cu precizia \(\varepsilon\) limita la \(+ \infty\) a șirului \((s_n)_{n\in \mathbb{N}^*}\), definit prin}
\label{sec:org2e14969}
\[#x_n = \left(1+\frac{1}{n}\right)^n, n \ge 1.\]


\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
#include <iostream>
#include <math.h>
using namespace std; // urgh
int main() {
    double eps;

    double x0;
    double x1 = 0;
    double delta = 10000;
    int n = 1;
    cin << eps;
    while (delta > eps) {
        x0 = x1;
        x1 = pow(1 + 1.0 / n, n);
        n++;
        delta = x1 - x0;
    }
    cout << x1 << endl;

    return 0;
}

\end{minted}
\pagebreak

\section*{Laborator 2}
\label{sec:org85960ce}
\subsection*{2. Suma cifrelor - corectitudinea}
\label{sec:orgbf804b1}

\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
#include <iostream>
using namespace std;

int main() {
    int n, s = 0;
    cin << n;
    int i = 0;
    while (n > 0) {
        // se putea și cu s += n%10; și n /= 10;
        s = s + n % 10;
        n = n / 10;
        i++;
    }
    cout << "suma = " << n << endl;
    return 0;
}
\end{minted}

I. Parțial corectitudinea
\newline

Considerăm aserțiunile de intrare și ieșire:

$P_{in} = \left\{ n = \sum\limits_{j=0}^{k} c_{j}10^{j};\ 
                c_{j} \in \overline{0,9} ,\ \forall j \in \overline{0,k};\ 
                c_{k} \neq 0 \right\}$,

$P_{out} = \left\{ s = \sum\limits_{j=0}^{k} c_{j} \right\}$.

\vspace{14pt}
Alegem proprietatea:

$I = \left\{
              n = \sum\limits_{j=0}^{k-i}c_{i+j}10^{j};
              s = \sum\limits_{j=0}^{i-1}c_{i-1-j}
 \right\}$.

\vspace{14pt}
La intrarea in buclă:

$i = 0$

$n = \sum\limits_{j=0}^{k}c_{j}10^{j}$

Deci propoziția
$I = \left\{
              n = \sum\limits_{j=0}^{k}c_{j}10^{j};
              s = \sum\limits_{j=0}^{-1}c_{-1-j} = 0
      \right\}$ 
 este adevărată.

Arătăm că propoziția $I$ este invariantă.

Presupunem $I$ adevărata la începutul iterației și $n \ne 0$; demonstrăm $I$ adevărata la sfârșitul iterației.

$n = \sum\limits_{j=0}^{n-i}c_{i+j}10^{j};\ 
s = \sum\limits_{j=0}^{i-1}c_{i-1-j}
$
\begin{minted}[linenos,firstnumber=10,frame=single]{c++}
    s = s + n % 10;
\end{minted}

$s = \left( \sum\limits_{j=0}^{i-1}c_{i-1-j} \right) + c_{i}
= \sum\limits_{j=0}^{i}c_{i-1-j}
$

\begin{minted}[linenos,firstnumber=11,frame=single]{c++}
    n = n / 10;
\end{minted}

$n = \left[ \left( \sum\limits_{j=0}^{k-i}c_{i+j}10^{j} \right) / \ 10 \right]
= \left[ \sum\limits_{j=0}^{k-i}c_{i+j}10^{j-1} \right]
= \left[ \sum\limits_{j=1}^{k-i}c_{i+j}10^{j-1} \right] + \left[c_{i}10^{-1} \right]
$

Cum $0 \le c_{i} \le 9 \implies 0 \le c_{i}10^{-1} \le 0.9 \implies \left[c_{i}10^{-1} \right] = 0$.

Deci $n = \left[ \sum\limits_{j=1}^{k-i}c_{i+j}10^{j-1} \right] = \sum\limits_{j=1}^{k-i}c_{i+j}10^{j-1} = \sum\limits_{j=0}^{k-i-1}c_{i+j+1}10^{j}$. 

\begin{minted}[linenos,firstnumber=12,frame=single]{c++}
    i++;
\end{minted}

Scriem $\mathit{res}$ și $n$ în funcție de noul $i$. Deci $i$ devine $i-1$.


$s = \sum\limits_{j=0}^{i-1}c_{i-1-j}$

$n = \sum\limits_{j=0}^{k-(i-1)-1}c_{i-1+j+1}10^{j} = \sum\limits_{j=0}^{k-i}c_{i+j}10^{j} $

Deci $I$ adevărata și la sfârșitul iterației.


\vspace{14pt}
La ieșirea din buclă:

$i = k + 1$

$n = \sum\limits_{j=0}^{k-(k+1)}c_{k+1+j}10^{j}
= \sum\limits_{j=0}^{-1}c_{k+1+j}10^{j} = 0$

$s = \sum\limits_{j=0}^{k+1-1}c_{k+1-1-j}
= \sum\limits_{j=0}^{k}c_{k-j}$

Deci $P_{out} = \left\{ s = \sum\limits_{j=0}^{k} c_{k-j} \right\} $ adevărată.

În concluzie algoritmului este parțial corect.

\vspace{14pt}
\noindent
II. Total corectitudinea
\newline

Considerăm funcția $t: \mathbb{N} \to \mathbb{N}$, $t(i) = k + 1 - i$;

$t(i + 1) - t(i) = k + 1 - (i + 1) - (k + 1 - i) = -1 < 0$, deci $t$ monoton strict descrescătoare.

$t(i) = 0 \iff i = k + 1 \iff n = \sum\limits_{j=0}^{-1}c_{k+1+j}10^{j} = 0\iff$ condiția de ieșire din buclă.

În concluzie algoritmului este total corect.

\pagebreak
\section*{Laborator 3}
\label{sec:org83fff05}
\subsection*{2. Descrieți un algoritm pentru calculul produsului scalar a doi vectori din \(\mathbb{R}^n\)\ldots{}}
\label{sec:org6ae562a}

\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
#include <iostream>
using namespace std;
// e important sa numerotați liniile aici
int main() {
    int n, x[100], y[100];
    cin >> n;
    cout << "x = ";
    for (int i = 0; i < n; ++i)
        cin >> x[i];
    cout << "y = ";
    for (int i = 0; i < n; ++i)
        cin >> y[i];

    int ps = 0;
    // sa spunem ca linia asta e ż (15, sau cat e ea)
    for (int i = 0; i < n; ++i) // ż+1
        ps = ps + x[i] * y[i];  // ż+2

    // și endl e oribil
    cout << ps << endl;
    return 0;
}
\end{minted}
\begin{center}
\begin{tabular}{lrll}
operația & cost & nr repetari & cost total\\
\hline
ż+2 & 3 & n & 3n\\
\end{tabular}
\end{center}

\(T(n) = 3n\)

\pagebreak
\section*{Laborator 4}
\label{sec:org8735eb4}
\subsection*{4. Cele mai mici 2 elemente dintr-o secvența}
\label{sec:orgc57d12c}
\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
#include <iostream>
using namespace std;

int main() {
    int n, x[100];
    cin >> n;
    for (int i = 0; i < n; ++i)
        cin >> x[i];

    // nu mai este 1989, putem declara variabile si la mijlocul functiei
    int m1, m2;
    // presupunem ca utilizatorul e rezonabil (nu e) si spunem ca n >= 2
    m1 = x[0];
    m2 = x[1];

    // m1 < m2
    if (m2 < m1) {
        int t = m1;
        m1 = m2;
        m2 = t; //in loc de t putem folosi x[0]
    }
    for (int i = 2; i < n; i++) {
        if (m1 >= x[i]) { // linia ż
            m2 = m1;
            m1 = x[i];
        }
        else if (m2 > x[i]) { // linia ż'
              m2 = x[i];
        }
    }

    cout << m1 << " " << m2 << endl;

    return 0;
}
\end{minted}

Cazul cel mai favoriabil (m1 >= x[i]) \(\forall i \in \{2, ...n-1\}\). T(n) = n-2 (se execută doar linia ż).

Cazul cel mai defavorabil (m1 < x[i]) \(\forall i \in \{2, ...n-1\}\) : T(n) = 2n-4 (se execută linia ż și ż').

Mereu \(T(n) \in \Theta(n)\).

\pagebreak

\section*{Laborator 5}
\label{sec:orge8193ca}
\subsection*{1. La o stație meteo \ldots{}.}
\label{sec:orgdc2d7f8}
\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
#include <iostream>
using namespace std;
struct Zi {
    int temp;
    int presiune;
};

int main() {
    int n;
    cin >> n;

    Zi x[100];
    for (int i = 0; i < n; ++i)
        cin >> x[i].temp >> x[i].presiune;

    // daca vreți alt algoritm de sortare inlocuiți aici:
    for (int i = 0; i < n; ++i) {
        for (int j = i+1; j < n; ++j) {
            if (x[i].temp > x[j].temp || (x[i].temp == x[j].temp &&
                x[i].presiune < x[j].presiune)) {
               Zi t = x[i];
               x[i] = x[j];
               x[j] = t;
            }
        }
    }
    for (int i = 0; i < n; ++i)
       cout << "t:" << x[i].temp << ", p: "<< x[i].presiune << endl;

    return 0;
}
\end{minted}
\pagebreak

\section*{Laborator 6}
\label{sec:org2a992ed}
\subsection*{5. Ackermann}
\label{sec:org329f8fd}
\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
int A(int m, int n) {
    if (m == 0) {
        return n + 1;
    }
    else {
        if (n == 0) return A(m-1, 1);
        else return A(m-1, A(m, n-1));
    }
}
\end{minted}

\subsection*{8. Baza 2}
\label{sec:orga7f62a3}

\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
#include <iostream>
using namespace std;

// 47.145518,27.6036255  bdm tss
int baza2(int n, char s[], int i) {
    if (n == 0) return i;
    // se poate si mai scurt ( s[i] = '0' + n%2;)
    if (n %2 == 0)
        s[i] = '0';
    else s[i] = '1';
    return baza2(n/2, s, i+1);
} 

int main() {
    char s[100];
    int n = 10;
    //cin >> n;

    int len = baza2(n, s, 0);
    for (int i = len -1; i >= 0; i--)
        cout << s[i];
    cout << endl;
    return 0;
}

\end{minted}
\pagebreak

\section*{Laborator 7}
\label{sec:org0c320c6}
\subsection*{2. Fibonacci}
\label{sec:orgb1d8f72}
\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
#include <iostream>
#include <math.h>
using namespace std;

double putere(double x, int n) {
    if (n == 1) return x;
    double r = putere(x, n / 2);
    r = r * r;
    if (n % 2 == 1) r = r * x;
    return r;
}
int fib(int n) {
    // daca vreti sa mearga si fib(0) (momentan da stack oveflow),
    // scrieti si linia asta:
    //if (n==0) return 0;

    // puteti defini o variabila 'double sqrt5 = sqrt(5);'
    return round(1.0 / sqrt(5) * 
                 (putere((1+sqrt(5))/2, n) - putere(1-sqrt(5)/2, n)));
    // varianta mai eficienta
    // return round(1.0 / sqrt(5) * (putere((1+sqrt(5))/2, n)));
}
int main() {
    int n;
    cin >> n;
    cout << fib(n) << endl;
    return 0;
}

\end{minted}

\pagebreak
\section*{Laborator 8}
\label{sec:org63cd70a}
\subsection*{6. Problema aia lunga cu integrala definita}
\label{sec:orga05ad32}
\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
// puteți sa nu scrieți liniile astea 2 si functia main
#include <iostream>
using namespace std;

double f(double x) {//f(x) = x^2
     // mai schimbati si voi putin expresia asta, cum ar fi 
     // return x; return 1; return sin(x); ....
     return x * x;
}

// Se poate face si ceva de genu asta ca f sa fie parametru:
//template<typename F>
//double integrate(F f, double a, double b, double eps = 1e-5) {
// sau așa:
//double integrate(double (*f)(double), double a, ...

// daca vreti sa va simtiti mai romani puteti scrie "integreaza"
double integrate(double a, double b, double eps) {
    double delta = b - a;
    if (delta < eps) {
        return delta * (f(a) + f(b)) / 2;
    }
    else {
        double c = (a+b)/2;
        return integrate(a, c, eps) + integrate(c, b, eps);
    }
}
int main() {
     double a, b, eps;
     //cin >> a >> b >> eps;
     // cu varianta mai faina merge si ceva de genu asta:
     // cout << integrate(sin, a, b) << endl;
     // doar ca n-ar trebui sa stim d-astea

     cout << integrate(a, b, eps) << endl;

     return 0;
}
\end{minted}
\pagebreak

\section*{Laborator 9}
\label{sec:org23647ad}
\subsection*{5. numere de 4 cifre cu suma cifrelor 11}
\label{sec:org1624535}
\begin{minted}[linenos,firstnumber=1,frame=single]{cpp}
#include <iostream>
using namespace std;

// blasfemie, x ar trebui sa fie parametru pt functii,
// dar asa ne spune in curs...
int x[4], n=4;

// am putea declara si asa:
//constexpr int n = 4;
//int x[n];
// dar nici asta n-ar trebui sa stim, si tot blasfemie e

void afiseaza() {
    for (int i = 0; i < n; i++)
       cout << x[i];
    cout << " ";
}
bool valid() {
    int s = 0;
    for (int i = 0; i < n; i++)
         s += x[i];
    return s == 11;
}

void btr(int k) {
    //int i = 0;
    //if (k == 0) i = 1;
    //for (; i < 10; i++) {...

    //varianta mai hardcore ar fi:
    //for (int i = k == 0; i < 10; i++) {...

    for (int i = 0; i < 10; i++) {
        // numerele nu incep cu 0
        // sunt metode mult mai eficiente pt verificarea asta
        // (vezi inceputul functiei)
        if (k == 0 && i == 0) continue;

        // putem verifica pe parcurs daca suma e mai mare decat 11,
        // si daca e, trecem la urmatorul
        // "exercitiu cititorului"
        x[k] = i;
        if (k == n - 1) {
            // valid() == true e redundant
            // 'valid()' deja e bool si 'valid() == true' e tot bool
            // si nu face absolut nimic in plus
            // if (valid()) e mai normal
            if (valid() == true)
                afiseaza();
        }
        else {
            btr(k+1);
        }
    }  
}

int main() {
    btr(0);
    return 0;
}
\end{minted}
\end{document}
